import Sequence from '../dataTypes/Sequence';
import Selector from '../Selector';
import Specificity from '../Specificity';
import isSubtypeOf from '../dataTypes/isSubtypeOf';

/**
 * @extends {Selector}
 */
class NameTest extends Selector {
	/**
	 * @param  {?string}  namespaceURI
	 * @param  {?string}  prefix
	 * @param  {string}   localName
	 */
	constructor (namespaceURI, prefix, nodeName) {
		var specificity = {
				[Specificity.NODENAME_KIND]: 1
			};
		if (nodeName === '*') {
			specificity = {
				[Specificity.NODETYPE_KIND]: 1
			};
		}
		super(new Specificity(specificity), { canBeStaticallyEvaluated: false });

		this._nodeName = nodeName;
		this._namespaceURI = namespaceURI;
		this._prefix = prefix;

	}

	evaluate (dynamicContext) {
		const node = dynamicContext.contextItem;
		const nodeIsElement = isSubtypeOf(node.type, 'element()');
		const nodeIsAttribute = isSubtypeOf(node.type, 'attribute()');
		if (!nodeIsElement && !nodeIsAttribute) {
			return Sequence.singletonFalseSequence();
		}
		// Easy cases first
		if (this._prefix === null && this._nodeName === '*') {
			return Sequence.singletonTrueSequence();
		}
		if (this._prefix === '*') {
			if (this._nodeName === '*') {
				return Sequence.singletonTrueSequence();
			}
			return this._nodeName === node.value.nodeName ?
				Sequence.singletonTrueSequence() : Sequence.singletonFalseSequence();

		}
		if (this._nodeName !== '*') {
			if (this._nodeName !== node.value.nodeName) {
				return Sequence.singletonFalseSequence();
			}
		}

		let resolvedNamespaceURI;
		if (this._namespaceURI) {
			resolvedNamespaceURI = this._namespaceURI;
		}
		else {
			if (this._prefix === null) {
				// An unprefixed QName, when used as a name test on an axis whose principal node kind is element,
				//    has the namespace URI of the default element/type namespace in the expression context;
				//    otherwise, it has no namespace URI.
				if (nodeIsElement) {
					resolvedNamespaceURI = dynamicContext.resolveNamespacePrefix('');
				}
				else {
					resolvedNamespaceURI = null;
				}
			}
			else {
				resolvedNamespaceURI = dynamicContext.resolveNamespacePrefix(this._prefix);
			}
		}
		return node.namespaceURI === resolvedNamespaceURI ? Sequence.singletonTrueSequence() : Sequence.singletonFalseSequence();
	}

	getBucket () {
		if (this._nodeName === '*') {
			// While * is a test matching attributes or elements, buckets are never used to match nodes.
			return 'type-1';
		}
		return 'name-' + this._nodeName;
	}
}

export default NameTest;
