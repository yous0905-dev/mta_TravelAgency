import Selector from '../Selector';
import Specificity from '../Specificity';
import Sequence from '../dataTypes/Sequence';
import FunctionItem from '../dataTypes/FunctionItem';

/**
 * @extends Selector
 */
class InlineFunction extends Selector {
	/**
	 * @param  {string}                name
	 * @param  {!Array<!Array<string>>}  paramDescriptions  An array of tuples of name and type of the parameters
	 * @param  {string}                returnType
	 * @param  {!Selector}              functionBody
	 */
	constructor (name, paramDescriptions, returnType, functionBody) {
		super(new Specificity({
			[Specificity.EXTERNAL_KIND]: 1
		}), Selector.RESULT_ORDERINGS.UNSORTED);

		this._name = name;
		this._paramDescriptions = paramDescriptions;
		this._returnType = returnType;
		this._functionBody = functionBody;

		var executeFunction = (dynamicContext, ...parameters) => {
			// Since functionCall already does typechecking, we do not have to do it here
			const scopedDynamicContext = dynamicContext.createScopedContext({
					// TODO: should we pass contextItem / sequence? check spec
					contextItem: null,
					contextSequence: null,
					variables: paramDescriptions.reduce((paramByName, [name, _type], i) => {
						paramByName[name] = parameters[i];
						return paramByName;
					}, Object.create(null))
				});

				return functionBody.evaluate(scopedDynamicContext);
			};

		this._functionItem = new FunctionItem(
			executeFunction,
			paramDescriptions.map(([_name, type]) => type),
			paramDescriptions.length,
			returnType || 'item()');
	}

	equals (otherSelector) {
		if (this === otherSelector) {
			return true;
		}

		if (!(otherSelector instanceof InlineFunction)) {
			return false;
		}
		const otherInlineFunction = /** @type {InlineFunction} */ (otherSelector);

		return this._functionBody.equals(otherInlineFunction._functionBody) &&
			this._paramDescriptions.length === otherInlineFunction._paramDescriptions.length &&
			this._paramDescriptions.every(function ([name , type], i) {
				return name === otherInlineFunction._paramDescriptions[i][0] &&
					type === otherInlineFunction._paramDescriptions[i][1];
			});
	}

	evaluate (_dynamicContext) {
		// TODO: bind this contextItem? check spec
		return Sequence.singleton(this._functionItem);
	}
}

export default InlineFunction;
