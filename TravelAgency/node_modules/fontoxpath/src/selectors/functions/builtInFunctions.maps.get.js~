define([
	'../dataTypes/Sequence',
	'../dataTypes/BooleanValue',
	'../dataTypes/MapValue',
	'../dataTypes/StringValue',
	'../dataTypes/IntegerValue'
], function (
	Sequence,
	BooleanValue,
	MapValue,
	StringValue,
	IntegerValue
) {
	'use strict';

	function isSameKey (k1, k2) {
		var k1IsStringLike = k1.instanceOfType('xs:string') || k1.instanceOfType('xs:anyURI') || k1.instanceOfType('xs:untypedAtomic');
		var k2IsStringLike = k2.instanceOfType('xs:string') || k2.instanceOfType('xs:anyURI') || k2.instanceOfType('xs:untypedAtomic');

		if (k1IsStringLike && k2IsStringLike) {
			// fn:codepoint-equal is ===
			return k1.value === k2.value;
		}

		var k1IsNumeric = k1.instanceOfType('xs:decimal') || k1.instanceOfType('xs:double') || k1.instanceOfType('xs:float');
		var k2IsNumeric = k2.instanceOfType('xs:decimal') || k2.instanceOfType('xs:double') || k2.instanceOfType('xs:float');
		if (k1IsNumeric && k2IsNumeric) {
			if (k1.isNaN() && k2.isNaN()) {
				return true;
			}
			return k1.value === k2.value;
		}
		// TODO: dateTime

		var k1IsOther = k1.instanceOfType('xs:boolean') || k1.instanceOfType('xs:hexBinary') || k1.instanceOfType('xs:duration') || k1.instanceOfType('xs:QName') || k1.instanceOfType('xs:NOTATION');
		var k2IsOther = k2.instanceOfType('xs:boolean') || k2.instanceOfType('xs:hexBinary') || k2.instanceOfType('xs:duration') || k2.instanceOfType('xs:QName') || k2.instanceOfType('xs:NOTATION');
		if (k1IsOther && k2IsOther) {
			return k1.value === k2.value;
		}

		return false;
	}

	function mapGet (_dynamicContext, mapSequence, key) {
		var map = mapSequence.value[0];
		var matchingPair = map.keyValuePairs.find(function (keyValuePair) {
				return isSameKey(keyValuePair.key, key.value[0]);
			});

		if (!matchingPair) {
			return Sequence.empty();
		}
		return matchingPair.value;
	}

	function mapMerge (_dynamicContext, mapSequence, optionMap) {
		var duplicationHandlingValue = optionMap.value[0].keyValuePairs.find(function (option) {
				return option.key.instanceOfType('xs:string') && option.key.value === 'duplicates';
			});
		var duplicationHandlingStrategy = !duplicationHandlingValue ? 'use-first' : duplicationHandlingValue.value.value[0].value;
		var result = mapSequence.value.reduce(function (resultingKeyValuePairs, map) {
				map.keyValuePairs.forEach(function (keyValuePair) {
					var existingPair = resultingKeyValuePairs.find(function (existingPair) {
							return isSameKey(existingPair.key, keyValuePair.key);
						});

					if (existingPair) {
						// Duplicate keys, use options to determine what to do
						switch (duplicationHandlingStrategy) {
							case 'reject':
								throw new Error('FOJS0003: Duplicate encountered when merging maps.');
							case 'use-last':
								// Use this one
								resultingKeyValuePairs.splice(resultingKeyValuePairs.indexOf(existingPair), 1, keyValuePair);
								return;
							case 'combine':
								resultingKeyValuePairs.splice(
									resultingKeyValuePairs.indexOf(existingPair),
									1,
									{
										key: keyValuePair.key,
										value: new Sequence(existingPair.value.value.concat(keyValuePair.value.value))
									});
								return;
							case 'use-any':
							case 'use-first':
							default:
								return;
						}
					}
					resultingKeyValuePairs.push(keyValuePair);
				});
				return resultingKeyValuePairs;
			}, []);

		return Sequence.singleton(new MapValue(result));
	}

	function mapPut (_dynamicContext, mapSequence, keySequence, value) {
		var resultingKeyValuePairs = mapSequence.value[0].keyValuePairs.concat();
		var indexOfExistingPair = resultingKeyValuePairs.findIndex(function (existingPair) {
				return isSameKey(existingPair.key, keySequence.value[0]);
			});
		if (indexOfExistingPair >= 0) {
			// Duplicate keys, use options to determine what to do
			resultingKeyValuePairs.splice(
				indexOfExistingPair,
				1,
				{
					key: keySequence.value[0],
					value: value
				});
		}
		else {
			resultingKeyValuePairs.push({
				key: keySequence.value[0],
				value: value
			});
		}
		return Sequence.singleton(new MapValue(resultingKeyValuePairs));
	}

	function mapEntry (_dynamicContext, keySequence, value) {
		return Sequence.singleton(new MapValue([{ key: keySequence.value[0], value: value }]));
	}

	function mapSize (_dynamicContext, mapSequence) {
		return Sequence.singleton(new IntegerValue(mapSequence.value[0].keyValuePairs.length));
	}

	function mapKeys (_dynamicContext, mapSequence) {
		var keys = mapSequence.value[0].keyValuePairs.map(
				function (pair) {
					return pair.key;
				});
		return new Sequence(keys);
	}

	function mapContains (_dynamicContext, mapSequence, keySequence) {
		var doesContain = mapSequence.value[0].keyValuePairs.some(
				function (pair) {
					return isSameKey(pair.key, keySequence.value[0]);
				});
		return Sequence.singleton(doesContain ? BooleanValue.TRUE : BooleanValue.FALSE);
	}

	function mapRemove (_dynamicContext, mapSequence, keySequence) {
		var resultingKeyValuePairs = mapSequence.value[0].keyValuePairs.concat();
		keySequence.value.forEach(function (key) {
			var indexOfExistingPair = resultingKeyValuePairs.findIndex(function (existingPair) {
					return isSameKey(existingPair.key, key);
				});
			if (indexOfExistingPair >= 0) {
				// Duplicate keys, use options to determine what to do
				resultingKeyValuePairs.splice(
					indexOfExistingPair,
					1);
			}
		});
		return Sequence.singleton(new MapValue(resultingKeyValuePairs));
	}

	function mapForEach (dynamicContext, mapSequence, functionItemSequence) {
		var resultingKeyValuePairs = mapSequence.value[0].keyValuePairs.map(function (keyValuePair) {
				var newValue = functionItemSequence.value[0].value
					.call(undefined, dynamicContext, Sequence.singleton(keyValuePair.key), keyValuePair.value);
				return {
					key: keyValuePair.key,
					value: newValue
				};
			});
		return Sequence.singleton(new MapValue(resultingKeyValuePairs));
	}

	// Note, because of circular dependencies, the getValue function is located here, and is patched onto the prototype of MapValue
	MapValue.prototype.getValue = mapGet;

	return {
		declarations: [
			{
				name: 'map:contains',
				argumentTypes: ['map(*)', 'xs:anyAtomicType'],
				returnType: 'xs:boolean',
				callFunction: mapContains
			},

			{
				name: 'map:entry',
				argumentTypes: ['xs:anyAtomicType', 'item()*'],
				returnType: 'map(*)',
				callFunction: mapEntry
			},

			{
				name: 'map:for-each',
				// TODO: reimplement type checking by parsing the types
				// argumentTypes: ['map(*)', 'function(xs:anyAtomicType, item()*) as item()*'],
				argumentTypes: ['map(*)', 'function(*)'],
				returnType: 'item()*',
				callFunction: mapForEach
			},

			{
				name: 'map:get',
				argumentTypes: ['map(*)', 'xs:anyAtomicType'],
				returnType: 'item()*',
				callFunction: mapGet
			},

			{
				name: 'map:keys',
				argumentTypes: ['map(*)'],
				returnType: 'xs:anyAtomicType*',
				callFunction: mapKeys
			},

			{
				name: 'map:merge',
				argumentTypes: ['map(*)*', 'map(*)'],
				returnType: 'map(*)',
				callFunction: mapMerge
			},

			{
				name: 'map:merge',
				argumentTypes: ['map(*)*'],
				returnType: 'map(*)',
				callFunction: function (dynamicContext, maps) {
					return mapMerge(dynamicContext, maps, Sequence.singleton(new MapValue([{
						key: new StringValue('duplicates'), value: Sequence.singleton(new StringValue('use-first'))
					}])));
				}
			},

			{
				name: 'map:put',
				argumentTypes: ['map(*)', 'xs:anyAtomicType', 'item()*'],
				returnType: 'map(*)',
				callFunction: mapPut
			},

			{
				name: 'map:remove',
				argumentTypes: ['map(*)', 'xs:anyAtomicType*'],
				returnType: 'map(*)',
				callFunction: mapRemove
			},

			{
				name: 'map:size',
				argumentTypes: ['map(*)'],
				returnType: 'xs:integer',
				callFunction: mapSize
			}

		],
		functions: {
			get: mapGet,
			merge: mapMerge,
			put: mapPut,
			size: mapSize
		}
	};
});
