import Sequence from '../dataTypes/Sequence';
import createAtomicValue from '../dataTypes/createAtomicValue';
import QName from '../dataTypes/valueTypes/QName';
import { validatePattern } from '../dataTypes/typeHelpers';

function fnQName (_dynamicContext, paramURI, paramQName) {
	const lexicalQName = paramQName.first().value;
	if (!validatePattern(lexicalQName, 'xs:QName')) {
		throw new Error('FOCA0002: The provided QName is invalid.');
	}
	const uri = paramURI.isEmpty() ? '' : paramURI.first().value;
	if (uri === '' && lexicalQName.includes(':')) {
		throw new Error('FOCA0002: The URI of a QNAme may not be empty if a prefix is provided.');
	}
	// Skip URI validation for now

	if (paramURI.isEmpty()) {
		return Sequence.singleton(new QName(null, null, lexicalQName));
	}
	if (!lexicalQName.includes(':')) {
		// Only a local part
		return Sequence.singleton(createAtomicValue(new QName('', uri, lexicalQName), 'xs:QName'));
	}
	const [prefix, localPart] = lexicalQName.split(':');
	return Sequence.singleton(createAtomicValue(new QName(prefix, uri, localPart), 'xs:QName'));

}

export default {
	declarations: [
		{
			name: 'QName',
			argumentTypes: ['xs:string?', 'xs:string'],
			returnType: 'xs:QName',
			callFunction: fnQName
		}
	]
};
