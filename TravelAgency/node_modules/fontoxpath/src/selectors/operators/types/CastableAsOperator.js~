import Sequence from '../../dataTypes/Sequence';
import Selector from '../../Selector';
import castToType from '../../dataTypes/castToType';
import createAtomicValue from '../../dataTypes/createAtomicValue';

/**
 * @extends {Selector}
 */
class CastableAsOperator extends Selector {
	/**
	 * @param  {!Selector}  expression
	 * @param  {!string}    targetType
	 * @param  {!boolean}   allowsEmptySequence
	 */
	constructor (expression, targetType, allowsEmptySequence) {
		super(expression.specificity);

		this._expression = expression;
		this._targetType = targetType;
		this._allowsEmptySequence = allowsEmptySequence;
	}

	evaluate (dynamicContext) {
		var evaluatedExpression = this._expression.evaluate(dynamicContext).atomize(dynamicContext);

		if (evaluatedExpression.isEmpty()) {
			return Sequence.singleton(createAtomicValue(this._allowsEmptySequence, 'xs:boolean'));
		}
		if (!evaluatedExpression.isSingleton()) {
			return Sequence.singleton(createAtomicValue(false, 'xs:boolean'));
		}
		throw new Error('XPTY0004: Sequence to cast is not singleton or empty.');
	}
}

export default CastableAsOperator;
