import builtinDataTypesByName from '../builtins/builtinDataTypesByName';

import castToAnyURI from '../casting/castToAnyURI';
import castToBase64Binary from '../casting/castToBase64Binary';
import castToBoolean from '../casting/castToBoolean';
import castToDate from '../casting/castToDate';
import castToDateTime from '../casting/castToDateTime';
import castToDayTimeDuration from '../casting/castToDayTimeDuration';
import castToDecimal from '../casting/castToDecimal';
import castToDouble from '../casting/castToDouble';
import castToDuration from '../casting/castToDuration';
import castToFloat from '../casting/castToFloat';
import castToGDay from '../casting/castToGDay';
import castToGMonth from '../casting/castToGMonth';
import castToGMonthDay from '../casting/castToGMonthDay';
import castToGYear from '../casting/castToGYear';
import castToGYearMonth from '../casting/castToGYearMonth';
import castToHexBinary from '../casting/castToHexBinary';
import castToInteger from '../casting/castToInteger';
import castToQName from '../casting/castToQName';
import castToString from '../casting/castToString';
import castToTime from '../casting/castToTime';
import castToUntypedAtomic from '../casting/castToUntypedAtomic';
import castToYearMonthDuration from '../casting/castToYearMonthDuration';

const PRIMITIVE_TYPES = [
	'xs:untypedAtomic',
	'xs:string',
	'xs:float',
	'xs:double',
	'xs:decimal',
	'xs:integer',
	'xs:duration',
	'xs:yearMonthDuration',
	'xs:dayTimeDuration',
	'xs:dateTime',
	'xs:time',
	'xs:date',
	'xs:gYearMonth',
	'xs:gYear',
	'xs:gMonthDay',
	'xs:gDay',
	'xs:gMonth',
	'xs:boolean',
	'xs:base64Binary',
	'xs:hexBinary',
	'xs:anyURI',
	'xs:QName',
	'xs:NOTATION'
];

export default function castToType (valueTuple, type) {
	const from = valueTuple.type,
		to = type,
		primitiveFrom = PRIMITIVE_TYPES.includes(from) ? from : builtinDataTypesByName[from].getPrimitiveType(),
		primitiveTo = PRIMITIVE_TYPES.includes(to) ? to : builtinDataTypesByName[to].getPrimitiveType();

	if (to === 'xs:NOTATION') {
		throw new Error('XPST0080: Casting to xs:NOTATION is not permitted.');
	}

	if (from === 'xs:anySimpleType' || to === 'xs:anySimpleType') {
		throw new Error('XPST0080: Casting from or to xs:anySimpleType is not permitted.');
	}

	if (from === 'xs:anyAtomicType' || to === 'xs:anyAtomicType') {
		throw new Error('XPST0080: Casting from or to xs:anyAtomicType is not permitted.');
	}

	// TODO: casting from union type

	const value = valueTuple.typedValue;

	let newType = castToPrimitiveType(value, primitiveFrom, primitiveTo);

	// xs:untypedAtomic, xs:integer, xs:yearMonthDuration, xs:dayTimeDuration are considered primitives
	// if (primitiveTo !== to) {
	// 	newType = castToDerivedType(value, to);
	// }

	return newType;
}

// function castToDerivedType (value, from, to) {
//
// }

function castToPrimitiveType (value, from, to) {
	const instanceOf = (type) => builtinDataTypesByName[from].instanceOfType(type);

	// Can always cast to string-like types
	if (to === 'xs:untypedAtomic') {
		return castToUntypedAtomic(value, instanceOf);
	}
	if (to === 'xs:string') {
		return castToString(value, instanceOf);
	}

	// Can try to cast from string-like types
	if (from === 'xs:untypedAtomic' || from === 'xs:string') {
		switch (to) {
			case 'xs:untypedAtomic':
				return castToUntypedAtomic(value, instanceOf);
			case 'xs:string':
				return castToString(value, instanceOf);
			case 'xs:float':
				return castToFloat(value, instanceOf);
			case 'xs:double':
				return castToDouble(value, instanceOf);
			case 'xs:decimal':
				return castToDecimal(value, instanceOf);
			case 'xs:integer':
				return castToInteger(value, instanceOf);
			case 'xs:duration':
				return castToDuration(value, instanceOf);
			case 'xs:yearMonthDuration':
				return castToYearMonthDuration(value, instanceOf);
			case 'xs:dayTimeDuration':
				return castToDayTimeDuration(value, instanceOf);
			case 'xs:dateTime':
				return castToDateTime(value, instanceOf);
			case 'xs:time':
				return castToTime(value, instanceOf);
			case 'xs:date':
				return castToDate(value, instanceOf);
			case 'xs:gYearMonth':
				return castToGYearMonth(value, instanceOf);
			case 'xs:gYear':
				return castToGYear(value, instanceOf);
			case 'xs:gMonthDay':
				return castToGMonthDay(value, instanceOf);
			case 'xs:gDay':
				return castToGDay(value, instanceOf);
			case 'xs:gMonth':
				return castToGMonth(value, instanceOf);
			case 'xs:boolean':
				return castToBoolean(value, instanceOf);
			case 'xs:base64Binary':
				return castToBase64Binary(value, instanceOf);
			case 'xs:hexBinary':
				return castToHexBinary(value, instanceOf);
			case 'xs:anyURI':
				return castToAnyURI(value, instanceOf);
			case 'xs:QName':
				return castToQName(value, instanceOf);
			// case 'xs:NOTATION':
			// 	return castToNOTATION(value, instanceOf);
		}
	}

	if (from === 'xs:float' ||
		from === 'xs:double' ||
		from === 'xs:decimal' ||
		from === 'xs:integer' ||
		from === 'xs:boolean') {
		switch (to) {
			case 'xs:float':
				return castToFloat(value, instanceOf);
			case 'xs:double':
				return castToDouble(value, instanceOf);
			case 'xs:decimal':
				return castToDecimal(value, instanceOf);
			case 'xs:integer':
				return castToInteger(value, instanceOf);
			case 'xs:boolean':
				return castToBoolean(value, instanceOf);
		}
	}
	if (from === 'xs:duration' ||
		from === 'xs:yearMonthDuration' ||
		from === 'xs:dayTimeDuration') {
		switch (to) {
			case 'xs:duration':
				return castToDuration(value, instanceOf);
			case 'xs:yearMonthDuration':
				return castToYearMonthDuration(value, instanceOf);
			case 'xs:dayTimeDuration':
				return castToDayTimeDuration(value, instanceOf);
		}
	}
	if (from === 'xs:dateTime') {
		switch (to) {
			case 'xs:dateTime':
				return castToDateTime(value, instanceOf);
			case 'xs:time':
				return castToTime(value, instanceOf);
			case 'xs:date':
				return castToDate(value, instanceOf);
			case 'xs:gYearMonth':
				return castToGYearMonth(value, instanceOf);
			case 'xs:gYear':
				return castToGYear(value, instanceOf);
			case 'xs:gMonthDay':
				return castToGMonthDay(value, instanceOf);
			case 'xs:gDay':
				return castToGDay(value, instanceOf);
			case 'xs:gMonth':
				return castToGMonth(value, instanceOf);
		}
	}
	if (from === 'xs:time' && to === 'xs:time') {
		return castToTime(value, instanceOf);
	}
	if (from === 'xs:date') {
		switch (to) {
			case 'xs:dateTime':
				return castToDateTime(value, instanceOf);
			case 'xs:date':
				return castToDate(value, instanceOf);
			case 'xs:gYearMonth':
				return castToGYearMonth(value, instanceOf);
			case 'xs:gYear':
				return castToGYear(value, instanceOf);
			case 'xs:gMonthDay':
				return castToGMonthDay(value, instanceOf);
			case 'xs:gDay':
				return castToGDay(value, instanceOf);
			case 'xs:gMonth':
				return castToGMonth(value, instanceOf);
		}
	}
	if (from === 'xs:gYearMonth' && to === 'xs:gYearMonth') {
		return castToGYearMonth(value, instanceOf);
	}
	if (from === 'xs:gYear' && to === 'xs:gYear') {
		return castToGYear(value, instanceOf);
	}
	if (from === 'xs:gMonthDay' && to === 'xs:gMonthDay') {
		return castToGMonthDay(value, instanceOf);
	}
	if (from === 'xs:gDay' && to === 'xs:gDay') {
		return castToGDay(value, instanceOf);
	}
	if (from === 'xs:gMonth' && to === 'xs:gMonth') {
		return castToGMonth(value, instanceOf);
	}
	if (from === 'xs:base64Binary' || from === 'xs:hexBinary') {
		if (to === 'xs:base64Binary') {
			return castToBase64Binary(value, instanceOf);
		}
		if (to === 'xs:hexBinary') {
			return castToHexBinary(value, instanceOf);
		}
	}

	if (from === 'xs:anyURI' && to === 'xs:anyURI') {
		return castToAnyURI(value, instanceOf);
	}

	// xs:NOTATION is still supported here because one can still cast to a derived type of NOTATION
	if (from === 'xs:QName' || from === 'xs:NOTATION') {
		if (to === 'xs:QName') {
			return castToQName(value, instanceOf);
		}
		if (to === 'xs:NOTATION') {
			return;
		}
	}

	throw new Error(`XPTY0004: Casting not supported from ${from} to ${to}.`);
}
