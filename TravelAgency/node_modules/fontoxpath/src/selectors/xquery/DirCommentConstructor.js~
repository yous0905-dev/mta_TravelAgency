import Selector from '../Selector';
import Specificity from '../Specificity';

import { DONE_TOKEN, ready } from '../util/iterators';
import createNodeValue from '../dataTypes/createNodeValue';
import isSubtypeOf from '../dataTypes/isSubtypeOf';
import atomize from '../dataTypes/atomize';
import Sequence from '../dataTypes/Sequence';
import castToType from '../dataTypes/castToType';
import concatSequences from '../util/concatSequences';

/**
 * @extends {Selector}
 */
class DirElementConstructor extends Selector {
	/**
	 * @param  {string}  prefix
	 * @param  {string}  name
	 * @param  {{name:string[],partialValues:(string|Selector)[]}[]}  attributes
	 * @param  {(Selector)[]}  contents  Strings and enclosed expressions
	 */
	constructor (prefix, name, attributes, contents) {
		super(new Specificity({}), {
			canBeStaticallyEvaluated: false,
			resultOrder: Selector.RESULT_ORDERINGS.UNSORTED
		});

		this._prefix = prefix;
		this._name = name;
		this._attributes = attributes;
		this._contents = contents;
	}

	evaluate (dynamicContext) {
		const nodesFactory = dynamicContext.nodesFactory;

		const attributes = this._attributes.map(({ name, partialValues }) => ({
			qualifiedName: {
				prefix: name[0],
				localPart: name[1]
			},
			valueSequences: partialValues.map(value=>value.evaluate(dynamicContext).atomize()),
			hasAllValues: false,
			value: null
		}));
		let attributePhaseDone = false;
		const normalAttributes = [];
		const additionalNamespacesInScope = Object.create(null);

		let childNodesPhaseDone = false;
		let childNodesSequences;

		let done = false;
		return new Sequence({
			next: () => {
				if (done) {
					return DONE_TOKEN;
				}
				if (!attributePhaseDone) {
					let unfinishedAttributeRetrieve = attributes.find(attr => !attr.hasAllValues);
					while (unfinishedAttributeRetrieve) {
						const vals = unfinishedAttributeRetrieve.valueSequences.map(sequence => sequence.tryGetAllValues());
						if (vals.some(val => !val.ready)) {
							return vals.find(val => !val.ready);
						}
						unfinishedAttributeRetrieve.value = vals
							.map(val => val.value.map(v => castToType(v, 'xs:string').value).join(' ')).join('');
						unfinishedAttributeRetrieve.hasAllValues = true;
						unfinishedAttributeRetrieve = attributes.find(attr => !attr.hasAllValues);
					}
					attributes.forEach(attribute => {
						if (attribute.qualifiedName.localPart === 'xmlns') {
							additionalNamespacesInScope[''] = attribute.value;
							return;
						}
						if (attribute.prefix === 'xmlns') {
							additionalNamespacesInScope[attribute.qualifiedName.localPart] = attribute.value;
							return;
						}
						normalAttributes.push(attribute);
					});
					attributePhaseDone = true;
				}

				const dynamicContextWithNamespaces = dynamicContext.scopeWithNamespaceResolver(
					prefix => {
						prefix = prefix || '';
						return prefix in additionalNamespacesInScope ?
							additionalNamespacesInScope[prefix] :
							dynamicContext.resolveNamespacePrefix(prefix);
					});

				if (!childNodesPhaseDone) {
					childNodesSequences = concatSequences(this._contents.map(contentSelector => contentSelector.evaluate(dynamicContextWithNamespaces)));
					childNodesPhaseDone = true;
				}

				const allChildNodesItrResult = childNodesSequences.tryGetAllValues();
				if (!allChildNodesItrResult.ready) {
					return allChildNodesItrResult;
				}

				const namespaceURI = dynamicContextWithNamespaces.resolveNamespacePrefix(this._prefix);

				const element = nodesFactory.createElementNS(namespaceURI, this._prefix ? this._prefix + ':' + this._name : this._name);

				attributes.forEach(attr => {
					const attrName = attr.qualifiedName.prefix ? attr.qualifiedName.prefix + ':' + attr.qualifiedName.localPart : attr.qualifiedName.localPart;
					const namespace = attr.qualifiedName.prefix ? dynamicContextWithNamespaces.resolveNamespacePrefix(attr.qualifiedName.prefix) : null;
					element.setAttributeNS(namespace, attrName, attr.value);
				});

				allChildNodesItrResult.value.forEach(childNode => {
					if (isSubtypeOf(childNode.type, 'node()')) {
						element.appendChild(childNode.value);
						return;
					}
					const atomizedValue = castToType(atomize(childNode), 'xs:string').value;
					element.appendChild(nodesFactory.createTextNode(atomizedValue));
				});

				done = true;

				return ready(createNodeValue(element));
			}
		});
	}
}

export default DirElementConstructor;
