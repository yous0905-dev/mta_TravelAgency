const {
	evaluateXPathToBoolean,
	evaluateXPathToNodes,
	evaluateXPathToString,
	evaluateXPathToFirstNode
} = require('fontoxpath');

const context = require.context('text!assets', true, /\.xml$/);
const parser = new DOMParser();

function getAsserterForTest (testCase) {
	const expectedResultNode = evaluateXPathToFirstNode('./result/*', testCase);
	switch (expectedResultNode.localName) {
		case 'error':
			const errorCode = evaluateXPathToString('@code', expectedResultNode);
			return (xpath, contextNode) =>
				chai.assert.throws(() => evaluateXPathToString(xpath, contextNode), errorCode);
		case 'assert':
		case 'assert-true':
			return (xpath, contextNode) => chai.assert.isTrue(evaluateXPathToBoolean(xpath, contextNode));
		case 'assert-eq':
			const equalWithString = evaluateXPathToString('./assert-eq', expectedResultNode);
			return (xpath, contextNode) => chai.assert.isTrue(evaluateXPathToBoolean(`(${xpath}) = (${equalWithString})`, contextNode));
		default:
			return () => {
				console.warn(`Skipped test, it was a ${expectedResultNode.localName}`);
				chai.fail();
			};
	}

}

context.keys().forEach((item) => {
	// Load the XML
	const doc = parser.parseFromString(context(item), 'text/xml');
	// Find all the tests we can run
	const testCases = evaluateXPathToNodes(`
/test-set/test-case[not(.//environment) and not(.//dependency[@value eq "XQ30+"])]`, doc);
	for (const testCase of testCases) {
		const testQuery = evaluateXPathToString('./test', testCase);
		const description = evaluateXPathToString('./description', testCase);
		const asserter = getAsserterForTest(testCase);
		it(description, () => {
			asserter(testQuery, doc);
		});
	}
});
