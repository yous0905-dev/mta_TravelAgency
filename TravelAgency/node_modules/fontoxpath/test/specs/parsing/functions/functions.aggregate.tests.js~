import slimdom from 'slimdom';

import blueprint from 'fontoxml-blueprints/readOnlyBlueprint';
import evaluateXPath from 'fontoxml-selectors/evaluateXPath';
import evaluateXPathToNumber from 'fontoxml-selectors/evaluateXPathToNumber';
import evaluateXPathToString from 'fontoxml-selectors/evaluateXPathToString';
import jsonMLMapper from 'fontoxml-dom-utils/jsonMLMapper';
import parseSelector from 'fontoxml-selectors/parsing/createSelectorFromXPath';

let documentNode;
beforeEach(() => {
	documentNode = slimdom.createDocument();
});

describe('numeric functions', () => {
	describe('avg', () => {
		it('returns the empty sequence if the empty sequence is passed',
		   () => chai.expect(evaluateXPath('avg(())', documentNode, blueprint)).to.deep.equal([]));
		it('returns the avg of integers',
		   () => chai.expect(evaluateXPathToNumber('avg((1, 2, 3))', documentNode, blueprint)).to.equal(2));
		it('returns the avg of doubles',
		   () => chai.expect(evaluateXPathToNumber('avg((1.5, 2.0, 2.5))', documentNode, blueprint)).to.equal(2));
		it('returns the avg of floats',
		   () => chai.expect(evaluateXPathToNumber('avg((1e-1, 1e1))', documentNode, blueprint)).to.equal(5.05));
		it('returns the avg of floats',
		   () => chai.expect(evaluateXPathToNumber('avg((1e-1, 1e1))', documentNode, blueprint)).to.equal(5.05));

		it('casts untypedAtomic to double');
	});

	describe('max()', () => {
		it('returns the max of integers',
		   () => chai.expect(evaluateXPathToNumber('max((1,3,2))', documentNode, blueprint)).to.equal(3));
		it('returns the max of strings',
		   () => chai.expect(evaluateXPathToString('max(("a", "b", "c"))', documentNode, blueprint)).to.equal('c'));
		it('returns the max of mixed floats and integers',
		   () => chai.expect(evaluateXPathToNumber('max((1, 1.5, 0.5))', documentNode, blueprint)).to.equal(1.5));
		it('returns the max of mixed floats, doubles and integers',
		   () => chai.expect(evaluateXPathToNumber('max((1, 1.5, 0.5e1))', documentNode, blueprint)).to.equal(5));
		it('throws a type error if the values are not of the same type',
		   () => chai.expect(() => evaluateXPath('max((1, "zero"))', documentNode, blueprint)).to.throw('FORG0006'));
		it('returns NaN if one of the values is NaN',
		   () => chai.expect(evaluateXPathToNumber('max((1, number("zero")))', documentNode, blueprint)).to.be.NaN);
		it('returns the empty sequence when passed the empty sequence',
		   () => chai.expect(evaluateXPath('max(())', documentNode, blueprint)).to.deep.equal([]));
		// TODO: when we have support for creating untypedAtomicValue items, when we have implemented the function conversion
		it('casts untypedAtomic to double');

		it('does not support setting the collation',
		   () => chai.expect(() => evaluateXPath('max((), "")', documentNode, blueprint)).to.throw());
	});

	describe('min()', () => {
		it('returns the min of integers',
		   () => chai.expect(evaluateXPathToNumber('min((1,3,2))', documentNode, blueprint)).to.equal(1));
		it('returns the min of strings',
		   () => chai.expect(evaluateXPathToString('min(("a", "b", "c"))', documentNode, blueprint)).to.equal('a'));
		it('returns the min of mixed floats and integers',
		   () => chai.expect(evaluateXPathToNumber('min((1, 1.5, 0.5))', documentNode, blueprint)).to.equal(0.5));
		it('returns the min of mixed floats, doubles and integers',
		   () => chai.expect(evaluateXPathToNumber('min((1, 1.5, 0.5e-1))', documentNode, blueprint)).to.equal(0.05));
		it('throws a type error if the values are not of the same type',
		   () => chai.expect(() => evaluateXPath('min((1, "zero"))', documentNode, blueprint)).to.throw('FORG0006'));
		it('returns NaN if one of the values is NaN',
		   () => chai.expect(evaluateXPathToNumber('min((1, number("zero")))', documentNode, blueprint)).to.be.NaN);
		it('returns the empty sequence when passed the empty sequence',
		   () => chai.expect(evaluateXPath('min(())', documentNode, blueprint)).to.deep.equal([]));
		// TODO: when we have support for creating untypedAtomicValue items, when we have implemented the function conversion
		it('casts untypedAtomic to double');

		it('does not support setting the collation',
		   () => chai.expect(() => evaluateXPath('min((), "")', documentNode, blueprint)).to.throw());
	});

	describe('sum', () => {
		it('returns zero if the empty sequence is passed',
		   () => chai.expect(evaluateXPathToNumber('sum(())', documentNode, blueprint)).to.equal(0));
		it('returns the $zero argument if the empty sequence is passed',
		   () => chai.expect(evaluateXPathToString('sum((), "ZERO")', documentNode, blueprint)).to.equal('ZERO'));
		it('returns the sum of integers',
		   () => chai.expect(evaluateXPathToNumber('sum((1, 2, 3))', documentNode, blueprint)).to.equal(6));
		it('returns the sum of doubles',
		   () => chai.expect(evaluateXPathToNumber('sum((1.5, 2.0, 2.5))', documentNode, blueprint)).to.equal(6));
		it('returns the sum of floats',
		   () => chai.expect(evaluateXPathToNumber('sum((1e-1, 1e1))', documentNode, blueprint)).to.equal(10.1));

		it('casts untypedAtomic to double');
	});
});
